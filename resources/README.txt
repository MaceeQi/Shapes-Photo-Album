In the previous assignment, a Shapes Photo Album model was designed based on the given specifications at the time. Once there was new information regarding the entire program and the required views, a few design changes and refactoring of code were made to the model. 

The package containing the classes for the model was changed to "model" instead of "shapesphotoalbum" for better distinction between the view and controller packages that were to be created. Our Color class was removed and replaced with the Java AWT Color class which better suited our needs since it could take color intensity values between 0 and 255, inclusive, and would also be compatible with our required views. In the Snapshots class, a getDescription() method was added so we could use it to display information about the snapshot in both views.

In the Shapes classes, the data types for sizes (horizontal and vertical sizes) and coordinates (x and y) were changed from doubles to integers. This change was made for better compatibility with the Java Swing class for our graphical view since the Graphics class required ints for drawing and coloring the shapes. Initially, our model restricted the size of our canvas to 1000 x 1000 for shapes to be added. This was because there was no specification on canvas size requirements so arbitrary values were chosen to restrict where shapes could be created and the assumption was that we could then later reflect this restriction in our views. However, with the new assignment we learned the shapes could be created and placed anywhere in infinite space (given the proper coordinate system), but only the shapes in a particular "viewport" would be visible in the view portion. With this in mind, the restrictions for where our shapes could be created (max x was 1000, max y was 1000), were removed, allowing shapes to have x, y coordinates anywhere. Finally, two methods were added to the Shapes interface: toSVG() and draw(). Both of these methods would help our shapes for both views (web and graphical) by allowing our shapes to be converted to a String that follows SVG code and calling the correct Graphics method for the respective shape for drawing, respectively. This would allow for runtime polymorphism in both the web and graphical views and remove the need to use "instance of" to determine which shape is being drawn on the respective view at the time. 

Moving on to the design of the rest of the program (view and controller), we knew that our application would be able to support two views - an interactive "graphical" view and a static "web" view. Since they are such different view types, our design of the view interface followed the SOLID principle: Interface Segregation (no client should be forced to depend on methods that it does not use). We have one common interface (IView) that contains the methods that are common to all types of views and then another interface that contains the methods common to all types of graphical user interface views (GUIView). This GUIView interface extends the IView interface. Our interactive "graphical" view implements this GUIView interface and our static "web" view implements the IView interface. Within the GraphicalView concrete class, there is an inner class (DrawPanel) that is the specific panel within our graphical window that paints the snapshot. This was made an inner class since it is tightly coupled with our graphical view.

Since both of the views are so different (one interactive, one static), two separate controllers were created (StaticController and InteractiveController), which both implement the common IController interface. The static controller works with static-type views (no additional features), whereas the interactive controller works with interactive GUI-type views (allows additional features). There is a separate Features interface that encapsulates high-level features of our program that the view should expose as a callback function. This is for interactive views and controllers so the InteractiveController also implements this interface. Having this Features interface avoids view-specific details leaking out of the view and the interactive controller wouldn't communicate with the view in a manner that reveals how the view is implemented. Our interactive controller implements these callback functions in its class so that it gets control in response to any event. So when a button is clicked, the listener attached to the button in the interactive GUI view calls the appropriate callback, which gives control to the interactive controller. This design was so that we could allow communication between the controller and the view to be independent of the view-specific details of which events are generated and which listeners are used. Finally, in both controller types, we delegate parsing the input file to a separate class that we made - the PhotoFileReader class. This is for delegation and to keep our controllers simple.